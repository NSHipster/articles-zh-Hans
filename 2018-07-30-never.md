# Never

---
title: Never
author: Mattt
translator: Xiang Wang
category: Swift
excerpt:
    â€œNeverâ€æ˜¯ä¸€ä¸ªçº¦å®šï¼Œè¡¨ç¤ºä¸€ä»¶äº‹åœ¨è¿‡å»æˆ–æœªæ¥çš„ä»»ä½•æ—¶æ®µéƒ½ä¸ä¼šå‘ç”Ÿã€‚å®ƒæ˜¯æ—¶é—´è½´ä¸Šçš„ä¸€ç§é€»è¾‘ä¸Šçš„ä¸å¯èƒ½ï¼Œåœ¨ä»»ä½•æ–¹å‘å»¶å±•å¼€å»éƒ½æ²¡æœ‰å¯èƒ½ã€‚
hiddenlang: ""
status:
    swift: 4.2
---

â€œNeverâ€ is a proposition that an event doesnâ€™t occur at any time in the past or future. Itâ€™s logical impossibility with a time axis; nothingness stretching out in all directions, forever.

â€¦which is why itâ€™s especially worrisome to encounter this comment in code:

â€œNeverâ€æ˜¯ä¸€ä¸ªçº¦å®šï¼Œè¡¨ç¤ºä¸€ä»¶äº‹åœ¨è¿‡å»æˆ–æœªæ¥çš„ä»»ä½•æ—¶æ®µéƒ½ä¸ä¼šå‘ç”Ÿã€‚å®ƒæ˜¯æ—¶é—´è½´ä¸Šçš„ä¸€ç§é€»è¾‘ä¸Šçš„ä¸å¯èƒ½ï¼Œåœ¨ä»»ä½•æ–¹å‘å»¶å±•å¼€å»éƒ½æ²¡æœ‰å¯èƒ½ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨ä»£ç ä¸­çœ‹åˆ° [è¿™æ ·çš„æ³¨é‡Š](https://github.com/search?q=%22this+will+never+happen%22&type=Code) ä¼šç‰¹åˆ«è®©äººä¸å®‰ã€‚

```swift
// this will never happen
```

Every compiler textbook will tell you that a comment like this one canâ€™t and wonâ€™t affect the behavior of compiled code. Murphyâ€™s Law says otherwise.

æ‰€æœ‰ç¼–è¯‘å™¨çš„æ•™ç§‘ä¹¦éƒ½ä¼šå‘Šè¯‰ä½ ï¼Œè¿™æ ·ä¸€å¥æ³¨é‡Šä¸èƒ½ä¹Ÿä¸ä¼šå¯¹ç¼–è¯‘å‡ºçš„ä»£ç äº§ç”Ÿä»»ä½•å½±å“ã€‚[å¢¨è²å®šç†](https://en.wikipedia.org/wiki/Murphy%27s_law) å‘Šè¯‰ä½ å¹¶éå¦‚æ­¤ï¼Œæ³¨é‡Šä»¥ä¸‹çš„ä»£ç ä¸€å®šä¼šè¢«è§¦å‘ã€‚

How does Swift keep us safe in the unpredictable chaos that is programming? Youâ€™ll never believe the answer: nothing and crashing.

é‚£ Swift æ˜¯å¦‚ä½•åœ¨è¿™ç§æ— æ³•é¢„æµ‹çš„ã€æ··ä¹±çš„å¼€å‘è¿‡ç¨‹ä¸­ä¿è¯å®‰å…¨å‘¢ï¼Ÿç­”æ¡ˆéš¾ä»¥ç½®ä¿¡ï¼šâ€œ**ä»€ä¹ˆéƒ½ä¸åš**â€ï¼Œä»¥åŠâ€œ**å´©æºƒ**â€ã€‚

---

Never was proposed as a replacement for the @noreturn attribute in SE-0102: â€œRemove @noreturn attribute and introduce an empty Never typeâ€, by Joe Groff.

ä½¿ç”¨ `Never` æ›¿æ¢ `@noreturn` ä¿®é¥°ç¬¦ï¼Œæ˜¯ç”± [Joe Groff](https://github.com/jckarter) åœ¨ [SE-0102: â€œRemove @noreturn attribute and introduce an empty Never typeâ€](https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md) ä¸­æå‡ºçš„ã€‚

Prior to Swift 3, functions that stop execution, like `fatalError(_:file:line:), abort()`, and `exit(_:)`, were annotated with the @noreturn attribute, which told the compiler that there was no return to the caller site.

åœ¨ Swift 3 ä¹‹å‰ï¼Œé‚£äº›è¦ä¸­æ–­æ‰§è¡Œçš„å‡½æ•°ï¼Œæ¯”å¦‚ `fatalError(_:file:line:)`ï¼Œ`abort()` å’Œ `exit(_:)`ï¼Œéœ€è¦ä½¿ç”¨ `@noreturn` ä¿®é¥°ç¬¦æ¥å£°æ˜ï¼Œè¿™ä¼šå‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæ‰§è¡Œå®Œæˆåä¸ç”¨è¿”å›è°ƒç”¨è¿™ä¸ªå‡½æ•°çš„ä½ç½®ã€‚

```swift
// Swift < 3.0
@noreturn func fatalError(_ message: () -> String = String(),
                               file: StaticString = #file,
                               line: UInt = #line)
```

After the change, fatalError and its trapping cohorts were declared to return the Never type:

ä» Swift 3 å¼€å§‹ï¼Œ`fatalError` å’Œå®ƒçš„ç›¸å…³å‡½æ•°éƒ½è¢«å£°æ˜ä¸ºè¿”å› `Never` ç±»å‹ã€‚

```swift
// Swift >= 3.0
func fatalError(_ message: @autoclosure () -> String = String(),
                     file: StaticString = #file,
                     line: UInt = #line) -> Never
```

For a type to replace the functionality of an annotation, it must be pretty complex, right? Nope! Actually, just the opposite â€” Never is arguably the simplest type in the entire Swift standard library:

ä½œä¸ºä¸€ä¸ªæ³¨é‡Šçš„æ›¿ä»£å“ï¼Œå®ƒè‚¯å®šæ˜¯å¾ˆå¤æ‚çš„ï¼Œå¯¹å—ï¼ŸNOï¼äº‹å®ä¸Šï¼Œæ°æ°ç›¸åï¼Œ`Never` å¯ä»¥è¯´æ˜¯æ•´ä¸ª Swift æ ‡å‡†åº“ä¸­æœ€ç®€å•çš„ä¸€ä¸ªç±»å‹ï¼š

```swift
enum Never {}
```

## Uninhabited Types
## æ— å®ä¾‹ç±»å‹ï¼ˆUninhabited Typesï¼‰

Never is an _uninhabited_ type, which means that it has no values. Or to put it another way, uninhabited types canâ€™t be constructed.

`Never` æ˜¯ä¸€ä¸ª_æ— å®ä¾‹_ï¼ˆ_Uninhabited_ï¼‰ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒæ²¡æœ‰ä»»ä½•å€¼ã€‚æˆ–è€…æ¢å¥è¯è¯´ï¼Œæ— å®ä¾‹ç±»å‹æ˜¯æ— æ³•è¢«æ„å»ºçš„ã€‚

Enumerations with no cases are the most common example of an uninhabited type in Swift. Unlike structures or classes, enumerations donâ€™t receive an initializer. And unlike protocols, enumerations are concrete types that can have properties, methods, generic constraints, and nested types. Because of this, uninhabited enumeration types are used throughout the Swift standard library to do things like namespace functionality and reason about types.

åœ¨ Swift ä¸­ï¼Œæ²¡æœ‰å®šä¹‰ä»»ä½• `case` çš„æšä¸¾æ˜¯æœ€å¸¸è§çš„ä¸€ç§æ— å®ä¾‹ç±»å‹ã€‚è·Ÿç»“æ„ä½“å’Œç±»ä¸åŒï¼Œæšä¸¾æ²¡æœ‰åˆå§‹åŒ–æ–¹æ³•ã€‚è·Ÿåè®®ä¹Ÿä¸åŒï¼Œæšä¸¾æ˜¯ä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œå¯ä»¥åŒ…å«å±æ€§ã€æ–¹æ³•ã€æ³›å‹çº¦æŸå’ŒåµŒå¥—ç±»å‹ã€‚æ­£å› å¦‚æ­¤ï¼ŒSwift æ ‡å‡†åº“å¹¿æ³›ä½¿ç”¨æ— å®ä¾‹çš„æšä¸¾ç±»å‹æ¥åšè¯¸å¦‚ [å®šä¹‰å‘½åç©ºé—´](https://github.com/apple/swift/blob/a4230ab2ad37e37edc9ed86cd1510b7c016a769d/stdlib/public/core/Unicode.swift#L918) ä»¥åŠ [æ ‡è¯†ç±»å‹çš„å«ä¹‰](https://github.com/apple/swift/blob/a6952decab6f918a9df3c6fa342153a9f9204f8e/stdlib/public/core/MemoryLayout.swift#L43) ä¹‹ç±»çš„äº‹æƒ…ã€‚

But Never isnâ€™t like that. It doesnâ€™t have any fancy bells or whistles. Itâ€™s special by virtue of it being what it is (or rather, isnâ€™t).

ä½† `Never` å¹¶ä¸è¿™æ ·ã€‚å®ƒæ²¡æœ‰ä»€ä¹ˆèŠ±å“¨çš„ä¸œè¥¿ï¼Œå®ƒçš„ç‰¹åˆ«ä¹‹å¤„å°±åœ¨äºï¼Œå®ƒå°±æ˜¯å®ƒè‡ªå·±ï¼ˆæˆ–è€…è¯´ï¼Œå®ƒä»€ä¹ˆéƒ½ä¸æ˜¯ï¼‰ã€‚

Consider a function declared to return an uninhabited type: Because uninhabited types donâ€™t have any values, the function canâ€™t return normally. (Because how could they?) Instead, the function must either stop execution or run indefinitely.

è¯•æƒ³ä¸€ä¸ªè¿”å›å€¼ä¸ºæ— å®ä¾‹ç±»å‹çš„å‡½æ•°ï¼šå› ä¸ºæ— å®ä¾‹ç±»å‹æ²¡æœ‰ä»»ä½•å€¼ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°æ— æ³•æ­£å¸¸çš„è¿”å›ã€‚ï¼ˆå®ƒè¦å¦‚ä½•ç”Ÿæˆè¿™ä¸ªè¿”å›å€¼å‘¢ï¼Ÿï¼‰æ‰€ä»¥ï¼Œè¿™ä¸ªå‡½æ•°è¦ä¹ˆåœæ­¢è¿è¡Œï¼Œè¦ä¹ˆæ— ä¼‘æ­¢çš„ä¸€ç›´è¿è¡Œä¸‹å»ã€‚

## Eliminating Impossible States in Generic Types

## æ¶ˆé™¤æ³›å‹ä¸­çš„ä¸å¯èƒ½çŠ¶æ€

Sure, this is interesting from a theoretical perspective, but what practical use does Never have for us?

ä»ç†è®ºè§’åº¦ä¸Šè¯´ï¼Œ`Never` ç¡®å®å¾ˆæœ‰æ„æ€ï¼Œä½†å®ƒåœ¨å®é™…åº”ç”¨ä¸­åˆèƒ½å¸®æˆ‘ä»¬åšä»€ä¹ˆå‘¢ï¼Ÿ

Not much â€” or at least not before the acceptance SE-0215: Conform Never to Equatable and Hashable.

åšä¸äº†ä»€ä¹ˆï¼Œæˆ–è€…è¯´åœ¨ [SE-0215: Conform Never to Equatable and Hashable](https://github.com/apple/swift-evolution/blob/master/proposals/0215-conform-never-to-hashable-and-equatable.md#conform-never-to-equatable-and-hashable) æ¨å‡ºä»¥å‰ï¼Œåšä¸äº†ä»€ä¹ˆã€‚

[Matt Diephouse](https://github.com/mdiep) åœ¨ææ¡ˆä¸­è§£é‡Šäº†ä¸ºä»€ä¹ˆè®©è¿™ä¸ªä»¤äººè´¹è§£çš„ç±»å‹å»éµå®ˆ `Equatable` å’Œå…¶ä»–åè®®ï¼š

> Never is very useful for representing impossible code. Most people are familiar with it as the return type of functions like fatalError, but Never is also useful when working with generic classes. For example, a Result type might use Never for its Value to represent something that always errors or use Never for its Error to represent something that never errors.

> `Never` åœ¨è¡¨ç¤ºä¸å¯èƒ½æ‰§è¡Œçš„ä»£ç æ–¹é¢éå¸¸æœ‰ç”¨ã€‚å¤§éƒ¨åˆ†äººç†Ÿæ‚‰å®ƒï¼Œæ˜¯å› ä¸ºå®ƒæ˜¯ `fatalError` ç­‰æ–¹æ³•çš„è¿”å›å€¼ï¼Œä½† `Never` åœ¨æ³›å‹æ–¹é¢ä¹Ÿéå¸¸æœ‰ç”¨ã€‚æ¯”å¦‚è¯´ï¼Œä¸€ä¸ª `Result` ç±»å‹å¯èƒ½ä½¿ç”¨ `Never` ä½œä¸ºå®ƒçš„ `Value`ï¼Œè¡¨ç¤ºæŸç§ä¸œè¥¿ä¸€ç›´æ˜¯é”™è¯¯çš„ï¼Œæˆ–è€…ä½¿ç”¨ `Never` ä½œä¸ºå®ƒçš„ `Error`ï¼Œè¡¨ç¤ºæŸç§ä¸œè¥¿ä¸€ç›´ä¸æ˜¯é”™è¯¯çš„ã€‚

Swift doesnâ€™t have a standard Result type, but most of them look something like this:

Swift æ²¡æœ‰æ ‡å‡†çš„ `Result` ç±»å‹ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹å®ƒä»¬æ˜¯è¿™ä¸ªæ ·å­çš„ï¼š

```swift
enum Result<Value, Error: Swift.Error> {
    case success(Value)
    case failure(Error)
}
```

Result types are used to encapsulate values and errors produced by functions that execute asynchronously (whereas synchronous functions can use throws to communicate errors).

`Result` ç±»å‹è¢«ç”¨æ¥å°è£…å¼‚æ­¥æ“ä½œç”Ÿæˆçš„è¿”å›å€¼å’Œå¼‚å¸¸ï¼ˆåŒæ­¥æ“ä½œå¯ä»¥ä½¿ç”¨ `throw` æ¥è¿”å›å¼‚å¸¸ï¼‰ã€‚

For example, a function that makes an asynchronous HTTP request might use a Result type to store either a response or an error:

æ¯”å¦‚è¯´ï¼Œä¸€ä¸ªå‘é€å¼‚æ­¥ HTTP è¯·æ±‚çš„å‡½æ•°å¯èƒ½ä½¿ç”¨ `Result` ç±»å‹æ¥å­˜å‚¨å“åº”æˆ–é”™è¯¯ï¼š

```swift
func fetch(_ request: Request, completion: (Result<Response, Error>) -> Void) {
    // ...
}
```

When calling that method, youâ€™d switch over result to handle .success and .failure separately:

è°ƒç”¨è¿™ä¸ªæ–¹æ³•åï¼Œä½ å¯ä»¥ä½¿ç”¨ `switch` æ¥åˆ†åˆ«å¤„ç†å®ƒçš„ `.success` å’Œ `.failure`ï¼š

```swift
fetch(request) { result in
    switch result {
    case .success(let value):
        print("Success: \(value)")
    case .failure(let error):
        print("Failure: \(error)")
    }
}
```

Now consider a function thatâ€™s guaranteed to always return a successful result in its completion handler:

ç°åœ¨å‡è®¾æœ‰ä¸€ä¸ªå‡½æ•°ä¼šåœ¨å®ƒçš„ `completion` ä¸­æ°¸è¿œè¿”å›æˆåŠŸç»“æœï¼š

```swift
func alwaysSucceeds(_ completion: (Result<String, Never>) -> Void) {
    completion(.success("yes!"))
}
```

By specifying Never as the resultâ€™s Error type, weâ€™re using the type system to signal that failure is not an option. Whatâ€™s really cool about this is that Swift is smart enough to know that you donâ€™t need to handle .failure for the switch statement to be exhaustive:

å°† `Result` çš„ `Error` ç±»å‹æŒ‡å®šä¸º `Never` åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»å‹æ£€æµ‹ä½“ç³»æ¥è¡¨æ˜å¤±è´¥æ˜¯æ°¸è¿œä¸å¯èƒ½å‘ç”Ÿçš„ã€‚è¿™æ ·åšçš„å¥½å¤„åœ¨äºï¼Œä½ ä¸éœ€è¦å¤„ç† `.failure`ï¼ŒSwift å¯ä»¥æ¨æ–­å‡ºè¿™ä¸ª `switch` è¯­å¥å·²ç»å¤„ç†äº†æ‰€æœ‰æƒ…å†µã€‚

```swift
alwaysSucceeds { (result) in
    switch result {
    case .success(let string):
        print(string)
    }
}
```

You can see this effect played out to its logical extreme in the implementation conforming Never to Comparable:

ä¸‹é¢è¿™ä¸ªä¾‹å­æ˜¯è®© `Never` éµå¾ª `Comparable` åè®®ï¼Œè¿™æ®µä»£ç æŠŠ `Never` ç”¨åˆ°äº†æè‡´ï¼š

```swift
extension Never: Comparable {
  public static func < (lhs: Never, rhs: Never) -> Bool {
    switch (lhs, rhs) {}
  }
}
```

Because Never is an uninhabited type, there arenâ€™t any possible values of it. So when we switch over lhs and rhs, Swift understands that there arenâ€™t any missing cases. And since all cases â€”- of which there arenâ€™t any â€” return Bool, the method compiles without a problem.

å› ä¸º `Never` æ˜¯ä¸€ä¸ªæ— å®ä¾‹ç±»å‹ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰ä»»ä½•å¯èƒ½çš„å€¼ã€‚æ‰€ä»¥å½“æˆ‘ä»¬ä½¿ç”¨ `switch` éå†å®ƒçš„ `lhs` å’Œ `rhs` æ—¶ï¼ŒSwift å¯ä»¥ç¡®å®šæ‰€æœ‰çš„å¯èƒ½æ€§éƒ½éå†äº†ã€‚æ—¢ç„¶æ‰€æœ‰çš„å¯èƒ½æ€§ â€” å®é™…ä¸Šè¿™é‡Œä¸å­˜åœ¨ä»»ä½•å€¼ â€” éƒ½è¿”å›äº† `Bool`ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–¹æ³•å°±å¯ä»¥æ­£å¸¸ç¼–è¯‘ã€‚

_Neat!_

_å·¥æ•´ï¼_

## Never as a Bottom Type
## ä½¿ç”¨ `Never` ä½œä¸ºå…œåº•ç±»å‹

As a corollary, the original Swift Evolution proposal for Never hints at the theoretical usefulness of the type with further enhancement:

å®é™…ä¸Šï¼Œå…³äº `Never` çš„ Swift Evolution ææ¡ˆä¸­å·²ç»æš—ç¤ºäº†è¿™ä¸ªç±»å‹åœ¨æœªæ¥å¯èƒ½æœ‰æ›´å¤šç”¨å¤„ï¼š

> An uninhabited type can be seen as a subtype of any other type â€” if evaluating an expression never produces a value, it doesnâ€™t matter what the type of that expression is. If this were supported by the compiler, it would enable some potentially useful thingsâ€¦


> ä¸€ä¸ªæ— å®ä¾‹ç±»å‹å¯ä»¥ä½œä¸ºå…¶ä»–ä»»æ„ç±»å‹çš„å­ç±»å‹ â€” å¦‚æœæŸä¸ªè¡¨è¾¾å¼æ ¹æœ¬ä¸å¯èƒ½äº§ç”Ÿä»»ä½•ç»“æœï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸éœ€è¦å…³å¿ƒè¿™ä¸ªè¡¨è¾¾å¼çš„ç±»å‹åˆ°åº•æ˜¯ä»€ä¹ˆã€‚å¦‚æœç¼–è¯‘å™¨æ”¯æŒè¿™ä¸€ç‰¹æ€§ï¼Œå°±å¯ä»¥å®ç°å¾ˆå¤šæœ‰ç”¨çš„åŠŸèƒ½â€¦â€¦

### Unwrap or Die
### è§£åŒ…æˆ–è€…æ­»äº¡

The forced unwrap operator (!) is one of the most controversial parts of Swift. At best, itâ€™s a necessary evil. At worst, itâ€™s a code smell that suggests sloppiness. And without additional information, it can be really tough to tell the difference between the two.

å¼ºåˆ¶è§£åŒ…æ“ä½œï¼ˆ`!`ï¼‰æ˜¯ Swift ä¸­æœ€å…·äº‰è®®çš„éƒ¨åˆ†ä¹‹ä¸€ã€‚ï¼ˆåœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸ªæ“ä½œç¬¦ï¼‰å¾€å¥½äº†è¯´ï¼Œæ˜¯æœ‰æ„ä¸ºä¹‹ï¼ˆåœ¨å¼‚å¸¸æ—¶æ•…æ„è®©ç¨‹åºå´©æºƒï¼‰ï¼›å¾€åäº†è¯´ï¼Œå¯èƒ½è¡¨ç¤ºä½¿ç”¨è€…æ²¡æœ‰è®¤çœŸæ€è€ƒã€‚åœ¨ç¼ºä¹å…¶ä»–ä¿¡æ¯çš„æƒ…å†µä¸‹ï¼Œå¾ˆéš¾çœ‹å‡ºè¿™ä¸¤è€…çš„åŒºåˆ«ã€‚

For example, consider the following code that assumes array to not be empty:

æ¯”å¦‚ï¼Œä¸‹é¢çš„ä»£ç å‡å®šæ•°ç»„ä¸€å®šä¸ä¸ºç©ºï¼Œ

```swift
let array: [Int]
let firstIem = array.first!
```

To avoid force-unwrapping, you could use a guard statement with conditional assignment instead:

ä¸ºäº†é¿å…å¼ºåˆ¶è§£åŒ…ï¼Œä½ å¯ä»¥ä½¿ç”¨å¸¦æ¡ä»¶èµ‹å€¼çš„ `guard` è¯­å¥ï¼š

```swift
let array: [Int]
guard let firstItem = array.first else {
    fatalError("array cannot be empty")
}
```

In the future, if Never is implemented as a bottom type, it could be used in the right-hand side of nil-coalescing operator expression.

æœªæ¥ï¼Œå¦‚æœ `Never` æˆä¸ºå…œåº•ç±»å‹ï¼Œå®ƒå°±å¯ä»¥ç”¨åœ¨ `nil-coalescing operator` è¡¨è¾¾å¼çš„å³è¾¹ã€‚

```swift
// Future Swift? ğŸ”®
let firstItem = array.first ?? fatalError("array cannot be empty")
```

If youâ€™re really motivated to adopt this pattern today, you can manually overload the ?? operator thusly (howeverâ€¦):

å¦‚æœä½ æƒ³ç°åœ¨å°±ä½¿ç”¨è¿™ç§æ¨¡å¼ï¼Œå¯ä»¥æ‰‹åŠ¨é‡è½½ `??` è¿ç®—ç¬¦ï¼ˆä½†æ˜¯â€¦â€¦ï¼‰ï¼š

```swift
func ?? <T>(lhs: T?, rhs: @autoclosure () -> Never) -> T {
    switch lhs {
    case let value?:
        return value
    case nil:
        rhs()
    }
}
```

> In the rationale for SE-0217: Introducing the !! â€œUnwrap or Dieâ€ operator to the Swift Standard Library, Joe Groff notes that â€œ[â€¦] We found that overloading [?? for Never] had unacceptable impact on type-checking performanceâ€¦â€. Therefore, itâ€™s recommended that you donâ€™t add this to your codebase.

> åœ¨æ‹’ç» [SE-0217: Introducing the !! â€œUnwrap or Dieâ€ operator to the Swift Standard Library](https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md#on-forced-unwraps) çš„[åŸå› è¯´æ˜](https://forums.swift.org/t/se-0217-the-unwrap-or-die-operator/14107/222)ä¸­, [Joe Groff](https://github.com/jckarter) æåˆ°ï¼Œâ€œæˆ‘ä»¬å‘ç°é‡è½½ [?? for Never] ä¼šå¯¹ç±»å‹æ£€æµ‹çš„æ€§èƒ½äº§ç”Ÿéš¾ä»¥æ¥å—çš„å½±å“â€ã€‚æ‰€ä»¥ï¼Œä¸å»ºè®®ä½ åœ¨è‡ªå·±çš„ä»£ç ä¸­æ·»åŠ ä¸Šé¢çš„ä»£ç ã€‚

### Expressive Throw
### è¡¨è¾¾å¼é£æ ¼çš„ Throw

Similarly, if throw is changed from being a statement to an expression that returns Never, you could use throw on the right-hand side of ??:

ç±»ä¼¼çš„ï¼Œå¦‚æœ `throw` å¯ä»¥ä»è¯­å¥å˜æˆä¸€ä¸ªè¿”å› `Never`çš„è¡¨è¾¾å¼ï¼Œä½ å°±å¯ä»¥åœ¨ `??` å³è¾¹ä½¿ç”¨ `throw`ã€‚

```swift
// Future Swift? ğŸ”®
let firstItem = array.first ?? throw Error.empty
```

### Typed Throws
### å¸¦ç±»å‹çš„ Throw

Looking even further down the road: If the throws keyword in function declarations added support for type constraints, then the Never type could be used to indicate that a function wonâ€™t throw (similar to the Result example before):

ç»§ç»­ç ”ç©¶ä¸‹å»ï¼šå¦‚æœå‡½æ•°å£°æ˜çš„ `throw` å…³é”®å­—æ”¯æŒç±»å‹çº¦æŸï¼Œé‚£ä¹ˆ `Never` å¯ä»¥ç”¨æ¥è¡¨æ˜æŸä¸ªå‡½æ•°ç»å¯¹ä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼ˆç±»ä¼¼äºåœ¨ä¸Šé¢çš„ `Result` ä¾‹å­ï¼‰ï¼š

```swift
// Future Swift? ğŸ”®
func neverThrows() throws<Never> {
    // ...
}

neverThrows() // `try` unnecessary because it's guaranteed to succeed (perhaps)
```

---

Making a claim that something will never be the case can feel like an invitation for the universe to prove otherwise. Whereas modal or doxastic logics allow for face-saving compromise (â€œit was true at the time, or so I believed!â€), temporal logic seems to hold propositions to a higher standard.

å£°ç§°æŸä¸ªäº‹æƒ…æ°¸è¿œä¸å¯èƒ½å‘ç”Ÿï¼Œå°±åƒæ˜¯å‘æ•´ä¸ªå®‡å®™å‘å‡ºé‚€è¯·ï¼Œæ¥è¯æ˜å®ƒæ˜¯é”™çš„ä¸€æ ·ã€‚æƒ…æ€é€»è¾‘ï¼ˆmodal logicï¼‰æˆ–è€…ä¿¡å¿µé€»è¾‘ï¼ˆdoxastic logicï¼‰å…è®¸ä¿é¢å­å¼çš„å¦¥åï¼ˆâ€œ_å®ƒå½“æ—¶æ˜¯å¯¹çš„ï¼Œæˆ–è€…æˆ‘æ˜¯è¿™ä¹ˆè®¤ä¸ºçš„ï¼_â€ï¼‰ï¼Œä½†æ—¶æ€é€»è¾‘ï¼ˆtemporal logicï¼‰ä¼¼ä¹å°†è¿™ä¸ªçº¦å®šæåˆ°äº†æ›´é«˜çš„ä¸€ä¸ªæ ‡å‡†ã€‚

Fortunately for us, Swift lives up to this higher standard thanks to the unlikeliest of types, Never.

å¹¸è¿çš„æ˜¯ï¼Œå¾—ç›Šäºæœ€ä¸åƒç±»å‹çš„ `Never`ï¼ŒSwift åˆ°è¾¾äº†è¿™ä¸ªé«˜æ ‡å‡†ã€‚


