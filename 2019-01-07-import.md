---
title: Swift Import Declarations
author: Mattt
category: Swift
excerpt: >-
  One of the first lessons we learn as software developers
  is how to organize concepts and functionality into discrete units.
  But what happens when namespaces collide
  and declarations lurk in the shadows?
status:
  swift: 4.2
---

---
title: Swift Import å£°æ˜
author: Mattt
category: Swift
excerpt: >-
  ä½œä¸ºè½¯ä»¶å¼€å‘äººå‘˜ï¼Œæˆ‘ä»¬å­¦åˆ°çš„ç¬¬ä¸€è¯¾æ˜¯å¦‚ä½•å°†æ¦‚å¿µå’ŒåŠŸèƒ½ç»„ç»‡æˆç‹¬ç«‹çš„å•å…ƒã€‚ä½†æ˜¯ï¼Œå½“å‘½åç©ºé—´å†²çªå’Œå£°æ˜éšè—åœ¨é˜´å½±æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼Ÿ
status:
  swift: 4.2
---

One of the first lessons we learn as software developers
is how to organize concepts and functionality into discrete units.
At the smallest level,
this means thinking about types and methods and properties.
These pieces then form the basis of one or more modules,
which may then be packaged into libraries or frameworks.

ä½œä¸ºè½¯ä»¶å¼€å‘äººå‘˜ï¼Œæˆ‘ä»¬å­¦åˆ°çš„ç¬¬ä¸€è¯¾æ˜¯å¦‚ä½•å°†æ¦‚å¿µå’ŒåŠŸèƒ½ç»„ç»‡æˆç‹¬ç«‹çš„å•å…ƒã€‚åœ¨æœ€å°çš„å±‚çº§ä¸Šï¼Œè¿™æ„å‘³ç€æ€è€ƒç±»å‹ã€æ–¹æ³•å’Œå±æ€§ã€‚è¿™äº›ä¸œè¥¿æ„æˆäº†æ¨¡å—ï¼ˆmoduleï¼‰çš„åŸºç¡€ï¼Œè€Œæ¨¡å—åˆå¯ä»¥è¢«æ‰“åŒ…æˆä¸º library æˆ–è€… frameworkã€‚

In this way,
import declarations are the glue that holds everything together.

åœ¨è¿™ç§æ–¹å¼ä¸­ï¼Œimport å£°æ˜æ˜¯å°†æ‰€æœ‰å†…å®¹ç»„åˆåœ¨ä¸€èµ·çš„ç²˜åˆå‰‚ã€‚

Yet despite their importance,
most Swift developers are familiar only with their most basic form:

å°½ç®¡ import å£°æ˜éå¸¸é‡è¦ï¼Œä½†å¤§éƒ¨åˆ† Swift å¼€å‘è€…éƒ½åªç†Ÿæ‚‰å®ƒçš„æœ€åŸºæœ¬ç”¨æ³•ï¼š

```swift
import <#module#>
```

This week on NSHipster,
we'll explore the other shapes
of this most prominent part of Swift.

æœ¬å‘¨çš„ NSHipster ä¸­ï¼Œæˆ‘ä»¬å°†æ¢ç´¢ Swift è¿™ä¸ªæœ€é‡è¦çš„åŠŸèƒ½çš„å…¶ä»–ç”¨æ³•ã€‚

---

An import declaration allows your code to access symbols
that are declared in other files.
However, if more than one module
declares a function or type with the same name,
the compiler may not be able to tell which one you want to call in code.

import å£°æ˜å…è®¸ä½ çš„ä»£ç è®¿é—®å…¶ä»–æ–‡ä»¶ä¸­å£°æ˜çš„ç¬¦å·ã€‚ä½†æ˜¯ï¼Œå¦‚æœå¤šä¸ªæ¨¡å—éƒ½å£°æ˜äº†ä¸€ä¸ªåŒåçš„å‡½æ•°æˆ–ç±»å‹ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°†æ— æ³•åˆ¤æ–­ä½ çš„ä»£ç åˆ°åº•æƒ³è°ƒç”¨å“ªä¸ªã€‚

To demonstrate this,
consider two modules representing the multisport competitions of
[Triathlon](https://en.wikipedia.org/wiki/Triathlon) and
[Pentathlon](https://en.wikipedia.org/wiki/Modern_pentathlon):

ä¸ºäº†æ¼”ç¤ºè¿™ä¸ªé—®é¢˜ï¼Œè€ƒè™‘ [é“äººä¸‰é¡¹ï¼ˆTriathlonï¼‰](https://zh.wikipedia.org/wiki/ä¸‰é¡¹å…¨èƒ½) å’Œ [é“äººäº”é¡¹ï¼ˆPentathlonï¼‰](https://zh.wikipedia.org/wiki/ç°ä»£äº”é¡¹) è¿™ä¸¤ä¸ªä»£è¡¨å¤šè¿åŠ¨æ¯”èµ›çš„æ¨¡å—:

A <dfn>triathlon</dfn> consists of three events:
swimming, cycling, and running.

<dfn>é“äººä¸‰é¡¹</dfn> åŒ…æ‹¬ä¸‰ä¸ªé¡¹ç›®ï¼šæ¸¸æ³³ã€è‡ªè¡Œè½¦å’Œè·‘æ­¥ã€‚

```swift
// é“äººä¸‰é¡¹æ¨¡å—
func swim() {
    print("ğŸŠâ€ Swim 1.5 km")
}

func bike() {
    print("ğŸš´ Cycle 40 km")
}

func run() {
    print("ğŸƒâ€ Run 10 km")
}
```

The modern <dfn>pentathlon</dfn> comprises five events:
fencing, swimming, equestrian, shooting, and running.

<dfn>é“äººäº”é¡¹</dfn> æ¨¡å—ç”±äº”ä¸ªé¡¹ç›®ç»„æˆï¼šå‡»å‰‘ã€æ¸¸æ³³ã€é©¬æœ¯ã€å°„å‡»å’Œè·‘æ­¥ã€‚

```swift
// é“äººäº”é¡¹æ¨¡å—
func fence() {
    print("ğŸ¤º Bout with Ã©pÃ©es")
}

func swim() {
    print("ğŸŠâ€ Swim 200 m")
}

func ride() {
    print("ğŸ‡ Complete a show jumping course")
}

func shoot() {
    print("ğŸ¯ Shoot 5 targets")
}

func run() {
    print("ğŸƒâ€ Run 3 km cross-country")
}
```

If we import either of the modules individually,
we can reference each of their functions
using their <dfn>unqualified</dfn> names without a problem.

å¦‚æœæˆ‘ä»¬å•ç‹¬ import å…¶ä¸­ä¸€ä¸ªæ¨¡å—ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å®ƒä»¬çš„ <dfn>éé™å®šï¼ˆunqualifiedï¼‰</dfn>åç§°å¼•ç”¨å®ƒä»¬çš„æ¯ä¸ªå‡½æ•°ï¼Œè€Œä¸ä¼šå‡ºç°é—®é¢˜ã€‚

```swift
import Triathlon

swim() // OK, calls Triathlon.swim
bike() // OK, calls Triathlon.bike
run() // OK, calls Triathlon.run
```

```swift
import Triathlon

swim() // æ­£ç¡®ï¼Œè°ƒç”¨ Triathlon.swim
bike() // æ­£ç¡®ï¼Œè°ƒç”¨ Triathlon.bike
run() // æ­£ç¡®ï¼Œè°ƒç”¨ Triathlon.run
```

But if we import both modules together,
we can't always use unqualified function names.
Triathlon and Pentathlon both include swimming and running,
so a reference to `swim()` is ambiguous.

ä½†æ˜¯å¦‚æœåŒæ—¶ import ä¸¤ä¸ªæ¨¡å—ï¼Œæˆ‘ä»¬ä¸èƒ½å…¨éƒ¨ä½¿ç”¨éé™å®šå‡½æ•°åã€‚é“äººä¸‰é¡¹å’Œäº”é¡¹éƒ½åŒ…æ‹¬æ¸¸æ³³å’Œè·‘æ­¥ï¼Œæ‰€ä»¥å¯¹ `swim()` çš„å¼•ç”¨æ˜¯æ¨¡ç³Šçš„ã€‚

```swift
import Triathlon
import Pentathlon

bike() // OK, calls Triathlon.bike
fence() // OK, calls Pentathlon.fence
swim() // Error, ambiguous
```

```swift
import Triathlon
import Pentathlon

bike() // æ­£ç¡®ï¼Œè°ƒç”¨ Triathlon.bike
fence() // æ­£ç¡®ï¼Œè°ƒç”¨ Pentathlon.fence
swim() // é”™è¯¯ï¼Œæ¨¡ç³Šä¸æ¸…
```

How do we reconcile this?
One strategy is to use
<dfn>fully-qualified names</dfn>
to work around any ambiguous references.
By including the module name,
there's no confusion about whether the program will swim
a few laps in a pool or a mile in open water.

å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿä¸€ç§ç­–ç•¥æ˜¯ä½¿ç”¨ <dfn>å…¨é™å®šåç§°ï¼ˆfully-qualified nameï¼‰</dfn> æ¥å¤„ç†ä»»ä½•ä¸æ˜ç¡®çš„å¼•ç”¨ã€‚é€šè¿‡åŒ…å«æ¨¡å—åç§°ï¼Œç¨‹åºæ˜¯è¦åœ¨æ¸¸æ³³æ± ä¸­æ¸¸å‡ åœˆï¼Œè¿˜æ˜¯åœ¨å¼€æ”¾æ°´åŸŸä¸­æ¸¸ä¸€è‹±é‡Œï¼Œå°±ä¸å­˜åœ¨æ··æ·†äº†ã€‚

```swift
import Triathlon
import Pentathlon

Triathlon.swim() // OK, fully-qualified reference to Triathlon.swim
Pentathlon.swim() // OK, fully-qualified reference to Pentathlon.swim
```

```swift
import Triathlon
import Pentathlon

Triathlon.swim() // æ­£ç¡®ï¼ŒæŒ‡å‘ Triathlon.swim çš„å…¨é™å®šå¼•ç”¨
Pentathlon.swim() // æ­£ç¡®ï¼ŒæŒ‡å‘ Pentathlon.swim çš„å…¨é™å®šå¼•ç”¨
```

Another way to resolve API name collision
is to change the import declaration
to be more selective about what's included from each module.

è§£å†³ API åç§°å†²çªçš„å¦ä¸€ç§æ–¹æ³•æ˜¯æ›´æ”¹ import å£°æ˜ï¼Œä½¿å…¶æ›´åŠ ä¸¥æ ¼åœ°æŒ‘é€‰éœ€è¦åŒ…å«æ¯ä¸ªæ¨¡å—å“ªäº›çš„å†…å®¹ã€‚

## Importing Individual Declarations

## import å•ä¸ªå£°æ˜

Import declarations have a form
that can specify individual
structures, classes, enumerations, protocols, and type aliases
as well as functions, constants, and variables declared at the top-level:

import å£°æ˜æä¾›äº†ä¸€ç§æ ·å¼ï¼Œå¯ä»¥æŒ‡å®šå¼•å…¥å®šä¹‰åœ¨é¡¶å±‚ï¼ˆtop-levelï¼‰çš„å•ä¸ªç»“æ„ä½“ã€ç±»ã€æšä¸¾ã€åè®®å’Œç±»å‹åˆ«åï¼Œä»¥åŠå‡½æ•°ã€å¸¸é‡å’Œå˜é‡ã€‚

```swift
import <#kind#> <#module.symbol#>
```

Here,
`<#kind#>` can be any of the following keywords:

è¿™é‡Œï¼Œ`<#kind#>` å¯ä»¥ä¸ºå¦‚ä¸‹çš„ä»»ä½•å…³é”®å­—ï¼š

| Kind        | Description |
| ----------- | ----------- |
| `struct`    | Structure   |
| `class`     | Class       |
| `enum`      | Enumeration |
| `protocol`  | Protocol    |
| `typealias` | Type Alias  |
| `func`      | Function    |
| `let`       | Constant    |
| `var`       | Variable    |

| Kind        | Description |
| ----------- | ----------- |
| `struct`    | ç»“æ„ä½“       |
| `class`     | ç±»          |
| `enum`      | æšä¸¾        |
| `protocol`  | åè®®        |
| `typealias` | ç±»å‹åˆ«å     |
| `func`      | å‡½æ•°        |
| `let`       | å¸¸é‡        |
| `var`       | å˜é‡        |

For example,
the following import declaration adds only the `swim()` function
from the `Pentathlon` module:

ä¾‹å¦‚ï¼Œä¸‹é¢çš„ import å£°æ˜åªæ·»åŠ äº† `Pentathlon` æ¨¡å—çš„ `swim()` å‡½æ•°:

```swift
import func Pentathlon.swim

swim() // OK, calls Pentathlon.swim
fence() // Error, unresolved identifier
```

```swift
import func Pentathlon.swim

swim() // æ­£ç¡®ï¼Œè°ƒç”¨ Pentathlon.swim
fence() // é”™è¯¯ï¼Œæ— æ³•è§£æçš„æ ‡è¯†
```

### Resolving Symbol Name Collisions

### è§£å†³ç¬¦å·åç§°å†²çª

When multiple symbols are referenced by the same name in code,
the Swift compiler resolves this reference
by consulting the following, in order:

å½“ä»£ç ä¸­å¤šä¸ªç¬¦å·è¢«åŒä¸€ä¸ªåå­—è¢«å¼•ç”¨æ—¶ï¼ŒSwift ç¼–è¯‘å™¨å‚è€ƒä»¥ä¸‹ä¿¡æ¯ï¼ŒæŒ‰ä¼˜å…ˆçº§é¡ºåºè§£æè¯¥å¼•ç”¨:

1. Local Declarations
2. Imported Declarations
3. Imported Modules

1. æœ¬åœ°çš„å£°æ˜
2. å•ä¸ªå¯¼å…¥ï¼ˆimportï¼‰çš„å£°æ˜
3. æ•´ä½“å¯¼å…¥çš„æ¨¡å—

If any of these have more than one candidate,
Swift is unable to resolve the ambiguity
and raises a compilation error.

å¦‚æœä»»ä½•ä¸€ä¸ªä¼˜å…ˆçº§æœ‰å¤šä¸ªå€™é€‰é¡¹ï¼ŒSwift å°†æ— æ³•è§£å†³æ­§ä¹‰ï¼Œè¿›è€Œå¼•å‘ç¼–è¯‘é”™è¯¯ã€‚

For example,
importing the `Triathlon` module
provides the `swim()`, `bike()`, and `run()` methods.
The imported `swim()` function declaration from the `Pentathlon`
overrides that of the `Triathlon` module.
Likewise, the locally-declared `run()` function
overrides the symbol by the same name from `Triathlon`,
and would also override any imported function declarations.

ä¾‹å¦‚ï¼Œæ•´ä½“å¯¼å…¥çš„ `Triathlon` æ¨¡å—ä¼šæä¾› `swim()`ã€`bike()` å’Œ `run()` æ–¹æ³•ï¼Œä½†ä» `Pentathlon` ä¸­å•ä¸ªå¯¼å…¥çš„ `swim()` å‡½æ•°å£°æ˜ä¼šè¦†ç›– `Triathlon` æ¨¡å—ä¸­çš„å¯¹åº”å‡½æ•°ã€‚åŒæ ·ï¼Œæœ¬åœ°å£°æ˜çš„ `run()` å‡½æ•°ä¼šè¦†ç›– `Triathlon` ä¸­çš„åŒåç¬¦å·ï¼Œä¹Ÿä¼šè¦†ç›–ä»»ä½•å•ä¸ªå¯¼å…¥çš„å‡½æ•°å£°æ˜ã€‚

```swift
import Triathlon
import func Pentathlon.swim

// Local function shadows whole-module import of Triathlon
func run() {
    print("ğŸƒâ€ Run 42.195 km")
}

swim() // OK, calls Pentathlon.swim
bike() // OK, calls Triathlon.bike
run() //  OK, calls local run
```

```swift
import Triathlon
import func Pentathlon.swim

// æœ¬åœ°çš„å‡½æ•°ä¼šé®ä½æ•´ä½“å¯¼å…¥çš„ Triathlon æ¨¡å—
func run() {
    print("ğŸƒâ€ Run 42.195 km")
}

swim() // æ­£ç¡®ï¼Œè°ƒç”¨ Pentathlon.swim
bike() // æ­£ç¡®ï¼Œè°ƒç”¨ Triathlon.bike
run() //  æ­£ç¡®ï¼Œè°ƒç”¨æœ¬åœ°çš„ run
```

The result of calling this code?
A bizarre multi-sport event involving
a few laps in the pool,
a modest bike ride,
and a marathon run.
_(@ us, IRONMAN)_

é‚£è¿™ä¸ªä»£ç çš„è¿è¡Œç»“æœæ˜¯ï¼Ÿä¸€ä¸ªå¤æ€ªçš„å¤šè¿åŠ¨æ¯”èµ›ï¼ŒåŒ…æ‹¬åœ¨ä¸€ä¸ªæ³³æ± é‡Œæ¸¸å‡ åœˆçš„æ¸¸æ³³ï¼Œä¸€ä¸ªé€‚åº¦çš„è‡ªè¡Œè½¦éª‘è¡Œï¼Œå’Œä¸€ä¸ªé©¬æ‹‰æ¾è·‘ã€‚_(@ æˆ‘ä»¬, é’¢é“ä¾ )_

{% warning %}
If a local or imported declaration collides with a module name,
the compiler first consults the declaration
and falls back to qualified lookup in the module.

å¦‚æœæœ¬åœ°æˆ–è€…å¯¼å…¥çš„å£°æ˜ï¼Œä¸æ¨¡å—çš„åå­—å‘ç”Ÿå†²çªï¼Œç¼–è¯‘å™¨é¦–å…ˆæŸ¥æ‰¾å£°æ˜ï¼Œç„¶ååœ¨æ¨¡å—ä¸­è¿›è¡Œé™å®šæŸ¥æ‰¾ã€‚

```swift
import Triathlon

enum Triathlon {
    case sprint, olympic, ironman
}

Triathlon.olympic // references local enumeration case
Triathlon.swim() // references module function
```

```swift
import Triathlon

enum Triathlon {
    case sprint, olympic, ironman
}

Triathlon.olympic // å¼•ç”¨æœ¬åœ°çš„æšä¸¾ case
Triathlon.swim() // å¼•ç”¨æ¨¡å—çš„å‡½æ•°
```

The Swift compiler doesn't communicate and cannot reconcile
naming collisions between modules and local declarations,
so you should be aware of this possibility
when working with dependencies.

Swiftç¼–è¯‘å™¨ä¸ä¼šé€šçŸ¥å¼€å‘è€…ï¼Œä¹Ÿæ— æ³•åè°ƒæ¨¡å—å’Œæœ¬åœ°å£°æ˜ä¹‹é—´çš„å‘½åå†²çªï¼Œå› æ­¤ä½¿ç”¨ä¾èµ–é¡¹æ—¶ï¼Œä½ åº”è¯¥äº†è§£è¿™ç§å¯èƒ½æ€§ã€‚

{% endwarning %}

### Clarifying and Minimizing Scope

### æ¾„æ¸…å’Œç¼©å°èŒƒå›´

Beyond resolving name collisions,
importing declarations can also be a way to
clarify your intent as a programmer.

é™¤äº†è§£å†³å‘½åå†²çªä¹‹å¤–ï¼Œimport å£°æ˜è¿˜å¯ä»¥ä½œä¸ºæ¾„æ¸…ç¨‹åºå‘˜æ„å›¾çš„ä¸€ç§æ–¹æ³•ã€‚

If you're,
for example,
using only a single function from a mega-framework like AppKit,
you might single that out in your import declaration.

ä¾‹å¦‚ï¼Œå¦‚æœåªä½¿ç”¨ AppKit è¿™æ ·å¤§å‹æ¡†æ¶ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆä½ å¯ä»¥åœ¨ import å£°æ˜ä¸­å•ç‹¬æŒ‡å®šè¿™ä¸ªå‡½æ•°ã€‚

```swift
import func AppKit.NSUserName

NSUserName() // "jappleseed"
```

This technique can be especially helpful
when importing top-level constants and variables,
whose provenance is often more difficult to discern
than other imported symbols.

é¡¶å±‚å¸¸é‡å’Œå˜é‡çš„æ¥æºé€šå¸¸æ¯”å…¶ä»–çš„å¯¼å…¥ç¬¦å·æ›´éš¾è¯†åˆ«ï¼Œåœ¨å¯¼å…¥å®ƒä»¬æ—¶ï¼Œè¿™ä¸ªæŠ€æœ¯å°¤å…¶æœ‰ç”¨ã€‚

For example,
the Darwin framework exports ---
among other things ---
a top-level `stderr` variable.
An explicit import declaration here
can preempt any questions during code review
about where that variable is coming from.

ä¾‹å¦‚ï¼ŒDarwin framework æä¾›çš„ä¼—å¤šåŠŸèƒ½ä¸­ï¼ŒåŒ…å«ä¸€ä¸ªé¡¶å±‚çš„ `stderr` å˜é‡ã€‚è¿™é‡Œçš„ä¸€ä¸ªæ˜¾å¼ import å£°æ˜å¯ä»¥åœ¨ä»£ç è¯„å®¡æ—¶ï¼Œæå‰é¿å…è¯¥å˜é‡æ¥æºçš„ä»»ä½•ç–‘é—®ã€‚

```swift
import func Darwin.fputs
import var Darwin.stderr

struct StderrOutputStream: TextOutputStream {
    mutating func write(_ string: String) {
        fputs(string, stderr)
    }
}

var standardError = StderrOutputStream()
print("Error!", to: &standardError)
```

## Importing a Submodule

## import å­æ¨¡å—

The final form of import declarations
offers another way to limit API exposure:

æœ€åä¸€ç§ import å£°æ˜æ ·å¼ï¼Œæä¾›äº†å¦ä¸€ç§é™åˆ¶ API æš´éœ²çš„æ–¹å¼ã€‚

```swift
import <#module.submodule#>
```

You're most likely to encounter submodules
in large system frameworks like AppKit and Accelerate.
These <dfn>[umbrella frameworks](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC)</dfn>
are no longer considered a best-practice,
but they served an important role during
Apple's transition to Cocoa in the early 00's.

ä½ å¾ˆå¯èƒ½åœ¨ AppKit å’Œ Accelerate ç­‰å¤§å‹çš„ç³»ç»Ÿ framework ä¸­é‡åˆ°å­æ¨¡å—ã€‚è™½ç„¶è¿™ç§ <dfn>[ä¼æ¶æ„ï¼ˆumbrella frameworkï¼‰](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html#//apple_ref/doc/uid/20002253-97623-BAJJHAJC)</dfn> ä¸å†æ˜¯ä¸€ç§æœ€ä½³å®è·µï¼Œä½†å®ƒä»¬åœ¨ 20 ä¸–çºªåˆè‹¹æœå‘ Cocoa è¿‡æ¸¡çš„è¿‡ç¨‹ä¸­å‘æŒ¥äº†é‡è¦ä½œç”¨ã€‚

For example,
you might import only the
[DictionaryServices](/dictionary-services/)
submodule from the
[Core Services framework](developer.apple.com/documentation/coreservices)
to insulate your code from the myriad deprecated APIs
like Carbon Core.

ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä»… import [Core Services framework](developer.apple.com/documentation/coreservices) çš„ [DictionaryServices](/dictionary-services/) å­æ¨¡å—ï¼Œä»è€Œå°†ä½ çš„ä»£ç ä¸æ— æ•°å·²åºŸå¼ƒçš„ APIï¼ˆå¦‚ Carbon Coreï¼‰éš”ç¦»å¼€æ¥ã€‚

```swift
import Foundation
import CoreServices.DictionaryServices

func define(_ word: String) -> String? {
    let nsstring = word as NSString
    let cfrange = CFRange(location: 0, length: nsstring.length)

    guard let definition = DCSCopyTextDefinition(nil, nsstring, cfrange) else {
        return nil
    }

    return String(definition.takeUnretainedValue())
}

define("apple") // "apple | ËˆapÉ™l | noun 1 the round fruit of a tree..."
```

In practice,
isolating imported declarations and submodules
doesn't confer any real benefit beyond signaling programmer intent.
Your code won't compile any faster doing it this way.
And since most submodules seem to re-import their umbrella header,
this approach won't do anything to reduce noise in autocomplete lists.

äº‹å®ä¸Šï¼Œå•ç‹¬å¯¼å…¥çš„å£°æ˜å’Œå­æ¨¡å—ï¼Œé™¤äº†æ¾„æ¸…ç¨‹åºå‘˜çš„æ„å›¾ï¼Œå¹¶ä¸èƒ½å¸¦æ¥ä»»ä½•çœŸæ­£çš„å¥½å¤„ã€‚è¿™ç§æ–¹å¼å¹¶ä¸ä¼šè®©ä½ çš„ä»£ç ç¼–è¯‘åœ°æ›´å¿«ã€‚ç”±äºå¤§éƒ¨åˆ†çš„å­æ¨¡å—ä¼¼ä¹éƒ½ä¼šé‡æ–°å¯¼å…¥å®ƒä»¬çš„ä¼å¤´æ–‡ä»¶ï¼ˆumbrella headerï¼‰ï¼Œå› æ­¤è¿™ç§æ–¹å¼ä¹Ÿæ²¡æ³•å‡å°‘è‡ªåŠ¨è¡¥å…¨åˆ—è¡¨ä¸Šçš„å™ªéŸ³ã€‚

---

Like many obscure and advanced topics,
the most likely reason you haven't heard about
these import declaration forms before
is that you don't need to know about them.
If you've gotten this far making apps without them,
you can be reasonably assured that you don't need to start using them now.

ä¸è®¸å¤šæ™¦æ¶©éš¾æ‡‚çš„é«˜çº§ä¸»é¢˜ä¸€æ ·ï¼Œä½ ä¹‹æ‰€ä»¥æ²¡æœ‰å¬è¯´è¿‡è¿™äº› import å£°æ˜æ ·å¼ï¼Œå¾ˆå¯èƒ½çš„æ˜¯å› ä¸ºä½ ä¸éœ€è¦äº†è§£å®ƒä»¬ã€‚å¦‚æœä½ å·²ç»åœ¨æ²¡æœ‰å®ƒä»¬çš„æƒ…å†µä¸‹å¼€å‘äº†å¾ˆå¤š APPï¼Œé‚£ä¹ˆä½ å®Œå…¨æœ‰ç†ç”±å¯ä»¥ç›¸ä¿¡ï¼Œä½ ä¸éœ€è¦å¼€å§‹ä½¿ç”¨å®ƒä»¬ã€‚

Rather, the valuable takeaway here is understanding
how the Swift compiler resolves name collisions.
And to that end,
import declarations are a concept of great import.

ç›¸åï¼Œè¿™é‡Œæ¯”è¾ƒæœ‰ä»·å€¼çš„æ”¶è·æ˜¯ç†è§£ Swift ç¼–è¯‘å™¨å¦‚ä½•è§£å†³å‘½åå†²çªã€‚ä¸ºæ­¤ï¼Œç†è§£ import å£°æ˜æ˜¯éå¸¸é‡è¦çš„ã€‚
